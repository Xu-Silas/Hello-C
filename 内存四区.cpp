#include<bits/stdc++.h>
using namespace std;
//全局变量：
int g_a = 10;
int g_b = 10; 

//const修饰的全局变量
const int c_g_a = 10; 

//int* func(int b) //形参数据也放在栈区 
//{   
//   b = 100;//b放在栈区 
//	int a = 10;//局部变量，存放在栈区，栈区的数据在函数执行完后自动释放 
	//return &a;//数据已经释放，无法再返回 
//}

int* func1()
{
	//利用new关键字，可以把数据开辟到堆区
	int* p1 = new int(10);//返回的是堆区数据的地址，不是数据本身，所以用指针接收 
	//创建指针类型的局部变量（在栈区），但是存放的是堆区的数据 
	return p1;
}

//面向对象 
int main()
{
	//1.内存分区模型 
	//代码区：存放函数体的二进制代码（所有代码存里面） 
	//全局区：全局变量，静态变量，常量 （该区域在程序结束后由操作系统释放 ） 
	//栈区：由编译器管理，存放局部变量，函数参数等 
	//堆区: 由程序员管理 
	//作用： 对不同区域的数据赋予不同生命周期，编程更灵活
	 
	 /*程序运行前：
	 被编译后，生成了exe的可执行程序，未执行程序前分为两个区域 */
	 
	 //代码区：
	    //存放CPU执行的机器指令
		//1.代码区是共享的，频繁执行的程序，内存中只需要有一份代码（点两次exe执行的是同一份代码） 
		//2.代码区是只读的， 生成的exe里面的代码只能读取但是不能修改，防止信息被篡改 
		
     //全局区:
     
        //创建普通局部变量(函数体内的创建的变量都是局部变量)：
		int a = 10;
		int b = 10;
		cout << "局部变量a的地址为：" << (long long)&a << endl;
		cout << "局部变量b的地址为：" << (long long)&b << endl;
		
		//全局变量 
		cout << "全局变量g_a的地址为：" <<(long long)&g_a << endl;
		cout << "全局变量g_b的地址为：" <<(long long)&g_b << endl;
		
		//静态变量
		static int s_a = 10;
		static int s_b = 10;
		cout << "静态变量s_a的地址为：" <<(long long)&s_a << endl;
		cout << "静态变量s_b的地址为：" <<(long long)&s_b << endl;
	    
	    //常量
		//1.字符串常量
		cout << "字符串常量的地址为："  << (long long)&"hello world"  <<endl;
		//2.const修饰的全局变量 
		cout << "全局常量c_g_a的地址为：" <<(long long)&c_g_a << endl;
		//3.const修饰的局部变量
		const int  c_l_a = 10;
		cout << "局部常量c_l_a的地址为：" <<(long long)&c_l_a << endl;//和局部变量放一起 
		
		
		//程序运行后： 
		
		//1.栈区（存放函数参数和局部变量 ）
		//由编译器管理开辟和释放
		//注意：不要返回局部变量的地址
		//int* p = func();
		//cout << *p <<endl;//第一次可以打印正确数据，是因为编译器做了保留 
		//cout << *p <<endl;//第二次不会保留 
		
		//2.堆区
		//由程序员分配释放,程序结束时由操作系统回收
		//在堆区开辟数据
		int* p = func1();
	    cout << *p << endl;
	    cout << *p << endl;
	    cout << *p << endl;
		
		 
}
